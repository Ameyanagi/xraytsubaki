use std::fmt::format;
use std::io::{BufWriter, Cursor};

use dioxus::html::form;
use dioxus::prelude::GlobalAttributes;
use dioxus::{html::label, prelude::*};

use image::codecs::pnm::BitmapHeader;
use plotters::{backend::RGBPixel, prelude::*};
use plotters_svg::SVGBackend;

use plotters::style::Palette100;
use plotters_canvas::CanvasBackend;

use base64::alphabet;
use base64::engine::{self, general_purpose};
use base64::Engine;

use image::{ImageBuffer, ImageOutputFormat, Rgb};

#[derive(dioxus::prelude::Props, PartialEq)]
pub struct PlotData {
    #[props(default = vec![vec![0.0, 1.0, 2.0, 3.0, 4.0]])]
    pub x: Vec<Vec<f64>>,

    #[props(default = vec![vec![0.0, 1.0, 2.0, 3.0, 4.0]])]
    pub y: Vec<Vec<f64>>,

    #[props(default = None)]
    pub labels: Option<Vec<String>>,

    #[props(default = "test".to_string())]
    pub title: String,

    #[props(default = "x".to_string())]
    pub x_label: String,

    #[props(default = "y".to_string())]
    pub y_label: String,

    #[props(default = 0.0)]
    pub x_min: f64,

    #[props(default = 1.0)]
    pub x_max: f64,

    #[props(default = 0.0)]
    pub y_min: f64,

    #[props(default = 1.0)]
    pub y_max: f64,

    #[props(default = 480)]
    pub width: usize,

    #[props(default = 480)]
    pub height: usize,
}

// fn cvt_base64(from: u8) -> char {
//     (if from < 26 {
//         b'A' + from
//     } else if from < 52 {
//         b'a' + from - 26
//     } else if from < 62 {
//         b'0' + from - 52
//     } else if from == 62 {
//         b'+'
//     } else {
//         b'/'
//     })
//     .into()
// }

// fn u8_to_String(data: &mut Vec<u8>) -> String {
//     let padding = (3 - data.len() % 3) % 3;
//     for _ in 0..padding {
//         data.push(0);
//     }

//     let mut buf = String::new();
//     buf.push_str("data:png;base64,");

//     let mut rem_bits = 0;
//     let mut rem_num = 0;

//     for byte in data {
//         let value = (rem_bits << (6 - rem_num)) | (byte >> (rem_num + 2));
//         rem_bits = byte & ((1 << (2 + rem_num)) - 1);
//         rem_num += 2;

//         buf.push(cvt_base64(value));
//         if rem_num == 6 {
//             buf.push(cvt_base64(rem_bits));
//             rem_bits = 0;
//             rem_num = 0;
//         }
//     }

//     buf
// }

const CUSTOM_ENGINE: engine::GeneralPurpose =
    engine::GeneralPurpose::new(&alphabet::STANDARD, general_purpose::NO_PAD);

pub fn LineChart(cx: Scope<PlotData>) -> Element {
    let mut buffer = String::new();
    let root = SVGBackend::with_string(&mut buffer, (480, 480)).into_drawing_area();
    // let root = BitMapBackend::new("plotters-doc-data/0.png", (640, 480)).into_drawing_area();
    root.fill(&WHITE).unwrap();
    let mut chart = ChartBuilder::on(&root)
        .caption(&cx.props.title, ("sans-serif", 25).into_font())
        .margin(2)
        .x_label_area_size(30)
        .y_label_area_size(30)
        .build_cartesian_2d(
            cx.props.x_min as f32..cx.props.x_max as f32,
            cx.props.y_min as f32..cx.props.y_max as f32,
        )
        .unwrap();

    chart
        .configure_mesh()
        .y_desc(&cx.props.y_label)
        .x_desc(&cx.props.x_label)
        .draw()
        .unwrap();

    let labels = if let Some(labels) = &cx.props.labels {
        if labels.len() < cx.props.x.len().min(cx.props.y.len()) {
            labels.to_owned().extend(
                std::iter::repeat("".to_string())
                    .take(cx.props.x.len().min(cx.props.y.len()) - labels.len())
                    .collect::<Vec<String>>(),
            );
        }

        labels.to_owned()
    } else {
        std::iter::repeat("".to_string())
            .take(cx.props.x.len().min(cx.props.y.len()))
            .collect::<Vec<String>>()
    };

    _ = cx
        .props
        .x
        .iter()
        .zip(cx.props.y.iter())
        .zip(labels.iter())
        .enumerate()
        .for_each(|(i, ((x, y), lab))| {
            let series = chart
                .draw_series(LineSeries::new(
                    x.iter().zip(y).map(|(x, y)| (*x as f32, *y as f32)),
                    &Palette100::pick(i.clone()),
                ))
                .unwrap();

            if lab != "" {
                series.label(lab).legend(move |(x, y)| {
                    PathElement::new(vec![(x, y), (x + 20, y)], &Palette100::pick(i.clone()))
                });
            } else {
            }
        });

    chart
        .configure_series_labels()
        .background_style(&WHITE.mix(0.8))
        .border_style(&BLACK)
        .draw()
        .unwrap();

    drop(chart);
    drop(root);

    render!(rsx!(div {
        onclick: move |event| {
            println!("event: {:?}", event);
        },

        class: "w-1/2 md:w-full",
        img{
            onclick: move |event| {
                println!("event: {:?}", event);
            },
            src: buffer.as_str(),
        }
        // dangerous_inner_html: "{buffer}"
    }))
}

use image::DynamicImage;

fn image_to_base64(img: &DynamicImage) -> String {
    let mut image_data: Vec<u8> = Vec::new();
    img.write_to(&mut Cursor::new(&mut image_data), ImageOutputFormat::Png)
        .unwrap();
    let res_base64 = general_purpose::STANDARD.encode(image_data);
    format!("data:image/png;base64,{}", res_base64)
}

pub fn LineChartBmp(cx: Scope<PlotData>) -> Element {
    let mut buffer: Vec<u8> = vec![0; cx.props.width * cx.props.height * 3];

    // let path = "test.png";
    let root = BitMapBackend::<RGBPixel>::with_buffer_and_format(
        &mut buffer,
        (cx.props.width as u32, cx.props.height as u32),
    )
    .unwrap()
    .into_drawing_area();

    root.fill(&WHITE).unwrap();
    let mut chart = ChartBuilder::on(&root)
        .caption(&cx.props.title, ("sans-serif", 25).into_font())
        .margin(2)
        .x_label_area_size(30)
        .y_label_area_size(30)
        .build_cartesian_2d(
            cx.props.x_min as f32..cx.props.x_max as f32,
            cx.props.y_min as f32..cx.props.y_max as f32,
        )
        .unwrap();

    // chart
    //     .configure_mesh()
    //     //     .y_desc(&cx.props.y_label)
    //     //     .x_desc(&cx.props.x_label)
    //     .draw()
    //     .unwrap();

    let labels = if let Some(labels) = &cx.props.labels {
        if labels.len() < cx.props.x.len().min(cx.props.y.len()) {
            labels.to_owned().extend(
                std::iter::repeat("".to_string())
                    .take(cx.props.x.len().min(cx.props.y.len()) - labels.len())
                    .collect::<Vec<String>>(),
            );
        }

        labels.to_owned()
    } else {
        std::iter::repeat("".to_string())
            .take(cx.props.x.len().min(cx.props.y.len()))
            .collect::<Vec<String>>()
    };

    _ = cx
        .props
        .x
        .iter()
        .zip(cx.props.y.iter())
        .zip(labels.iter())
        .enumerate()
        .for_each(|(i, ((x, y), lab))| {
            let series = chart
                .draw_series(LineSeries::new(
                    x.iter().zip(y).map(|(x, y)| (*x as f32, *y as f32)),
                    &Palette100::pick(i.clone()),
                ))
                // .draw_series(x.iter().zip(y).map(|(x, y)| {
                //     Circle::new((*x as f32, *y as f32), 20, &Palette100::pick(i.clone()))
                // }))
                .unwrap();

            if lab != "" {
                series.label(lab).legend(move |(x, y)| {
                    PathElement::new(vec![(x, y), (x + 20, y)], &Palette100::pick(i.clone()))
                });
            } else {
            }
        });

    chart
        .configure_series_labels()
        .background_style(&WHITE.mix(0.8))
        .border_style(&BLACK)
        .draw()
        .unwrap();

    drop(chart);
    drop(root);

    let borrowed_image = ImageBuffer::<Rgb<u8>, Vec<u8>>::from_raw(
        cx.props.width as u32,
        cx.props.height as u32,
        buffer,
    )
    .unwrap();

    let image = format!(
        "<img src=\"{}\" />",
        image_to_base64(&DynamicImage::ImageRgb8(borrowed_image))
    );

    render!(rsx!(div {
        dangerous_inner_html: "{image}"
    }))
}

pub fn LineChartCanvas(canvas_id: &str) -> Result<(), Box<dyn std::error::Error>> {
    let backend = CanvasBackend::new(canvas_id);
    let backend = match backend {
        Some(backend) => backend,
        None => return Ok(()),
    };
    let root = backend.into_drawing_area();
    let font: FontDesc = ("sans-serif", 20.0).into();
    let power = 2;

    root.fill(&WHITE)?;

    let mut chart = ChartBuilder::on(&root)
        .margin(20u32)
        .caption(format!("y=x^{}", power), font)
        .x_label_area_size(30u32)
        .y_label_area_size(30u32)
        .build_cartesian_2d(-1f32..1f32, -1.2f32..1.2f32)?;

    chart.configure_mesh().x_labels(3).y_labels(3).draw()?;

    chart.draw_series(LineSeries::new(
        (-50..=50)
            .map(|x| x as f32 / 50.0)
            .map(|x| (x, x.powf(power as f32))),
        &RED,
    ))?;

    root.present()?;
    Ok(())
    // return Ok(chart.into_coord_trans());
}
